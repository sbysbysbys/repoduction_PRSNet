# 任务报告_PRS-Net
__孙博一__       __中国科学院大学__      __计算机科学与技术__
## 日程
* 7.10：阅读论文，初步设计
* 7.11：详细设计，跑通源代码，开始入手代码
* 7.12：写代码
* 7.13：写代码
* 7.14：写完基本代码，跑输出，做可视化
* 7.15：调试，前些天的训练集跑模型，写报告
* 7.16：写报告

## 项目目录
- reproduction
  - checkpoints
    - model
      - 实验模型.pth
  - datasets
    - shapenet
      - train
        - 训练集.mat
      - test
        - 测试集.mat
  - results
    - compare
      - 实验结果.mat
  - visualization
    - generateSurfacePlot.m 结果可视化
    - visPointsPlaneAndRot.m
  - config.yaml
  - model.py
  - test.py
  - train.py
  - utils.py


## 论文总结与分布实现
本复现任务中的所有代码（除数据初处理，即原实验的\preprocess\precomputeShapeData.m）均为自主完成。

###     概述
*   PRS-Net是一种无监督的深度学习方法，用于检测三维物体的全局平面反射对称性。
*   思路是将对称性检测问题建模为可微函数，该函数可以通过CNN神经网络获得。
*   进一步设计了专用的对称距离损失和正则化损失，以避免生成重复的对称平面。

###     网络结构设置
*    编码器部分是五层的卷积加上最大池化层，输入为体素，维度是32*32*32
*    本文在后面进一步探讨了体素的维度（16，32，64，128）对于网络的影响。
*    结果表明：在32的时候整个网络的性能达到最大值，文中对于这一部分的解释是由于参数的过拟合。
*    实验中，值得注意的是在计算对称损失的时候，使用文中的方法，取出了对应体素中心的的closepoint作为计算对称损失的一个指标。需要注意的是，这种拟合方法的误差是不可忽视的，随机取的点集计算对称点的过程中，假设对称点的落点随机，每个体素是0.03 = 1/32大小的方块，那么对应点在体素中与体素中心的距离这个误差就在0.005左右。
*    但同时，虽然这个误差是不可避免的，但是也是可接受的，由于取点的差异性和3d模型的随机性，并不会造成影响。
*    后面分别对6个子任务使用全连接层，最终压缩成一个4元张量，由于平面和转轴都是四元张量可表示的，最终再加上初始化参数，得到最终的结果。
*    在源代码中，初始化参数加在了模型下最后一层全连接层的偏移上，同时由于每次进入最后一层都会更新偏移，那么初始化参数就相当于是一个常量加上。那么这个初始化参数的作用是什么？去掉这个参数会有什么样的后果。
*    在我进行设计的时候，我一直都不知道初始化参数是加在那一处。因为在我的想法里，最后一层进行的输出就可以作为表示对称轴和对称平面的四元组，那么初始化的意义在哪里？
*    我的想法是：
*    1.确定张量元素的大小左右区间，在初始化的时候，我们现将其中的一维设成1，那么在后面学习的时候，就能有一个合适的参考。
*    2.增加模型的变动性，让模型更有效的学习。
*        首先是，在实际生活中，以及训练集中，那些模型如果有更多的对称轴或者对称平面，那么那些对称轴或者是对称平面多半是相互正交的，这样一来，对于同样产出64大小的参数，类似的矩阵变换就能得出较好的效果，也就是对于大多数模型来说，这样来初始化对于全连接层的参数是友好的。
*        举个例子：我们在一维的平面上去做预测，预测的范围就假设在[-2,2]，那么如果把3个参数参数都放在原点，那么参数学习的平均移动范围平均是在3左右，如果初始化在-1，0，1，那么模型会将这几个参数往最近的预测值去预测，就会小一点。大概能类比到这个问题。我猜的，不一定对。
    
*    代码方面，模型在models文件中

###     损失函数
*    损失函数的设置是有效的。分为对称性误差和正则化误差。
*    对称性误差：
*    1.平面的对称性误差：
*        平面的对称性误差比较好求，通过公式求就可以。
*       需要注意的是，这里我们进行求值的时候，是对于点集的运算，同时的，对于一个batch的张量进行的运算，张量的维度是一个难以估量的一件事。在utils中，我设置了对应的类表示对称面和对称轴。同样设置了对应的操作，以便于不仅能够在训练的时候使用并且存在梯度，同时能够调试并且在后面做结果的时候友善输出。
```
class SymmetryPlane:
    def __init__(self,data,plane):

    # 对称点
    def sympoint(self,p):
    
    # 对称点集
    def sympoints(self):

    # 最短距离 # 对称距离损失
    def Lsd(self):

```


    






